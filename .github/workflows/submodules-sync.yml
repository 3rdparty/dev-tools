# This workflow will bring the submodules of this repository in sync with their
# latest HEAD. If there are changes to be made it will open a new PR (or update
# an existing PR if one already exists) for those changes, and set that PR up
# auto-merge as soon as all checks pass.
name: Submodules Sync

on:
  workflow_call:
    secrets:
      private_repo_access_as_rebot_token:
        required: true
      token_github:
        required: true

jobs:
  # Since we want to create one PR per each submodule on submodule change
  # we introduce one more build step to generate matrix of changed submodules paths
  # in order to pass it to the main Submodules sync job then.
  build-matrix:
    runs-on: ubuntu-latest
    steps:
      # Checkout the repository to the GitHub Actions runner.
      - name: Checkout repo
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.private_repo_access_as_rebot_token }}
          submodules: recursive
      - id: set-matrix
        name: Set matrix based on modified submodules
        run: |
          # Update references.
          git submodule update --recursive --remote
          # The following condition is needed to set required outputs.
          # The step generates two outputs: `path_matrix` and the flag `contains_changes`.
          # `path_matrix` output contains list of changed submodules,
          # `contains_changes` is a bolean parameter and contains flag `true` or `false`.
          # The flag is used by the main build job.
          # If it is false next job doesn't start.
          if [[ $(git ls-files -m) ]]; then
              echo "::set-output name=path_matrix::[$(git ls-files -m | awk '{ printf "%s\"%s\"", (NR==1?"":", "), $0 } END{ print "" }')]"
              echo "::set-output name=contains_changes::['true']"
          else
              echo "No changed files found"
              echo "::set-output name=contains_changes::['false']"
          fi
    outputs:
      path_matrix: ${{ steps.set-matrix.outputs.path_matrix }}
      contains_changes: ${{ steps.set-matrix.outputs.contains_changes }}

  sync:
    name: Submodules Sync
    needs: build-matrix
    # Condition to run the job depending on `contains_changes` flag generated in previous job.
    if: contains(needs.build-matrix.outputs.contains_changes, 'true')
    runs-on: ubuntu-latest
    # We set strategy matrix to work with changes of each submodule separately.
    strategy:
      matrix:
         path: ${{ fromJson(needs.build-matrix.outputs.path_matrix) }}
    defaults:
      run:
        shell: bash

    steps:
    # Checkout the repository to the GitHub Actions runner.
    - name: Checkout reboot-dev/respect
      uses: actions/checkout@v2
      with:
        # The private submodules need to get pulled using some credentials.
        # We can choose between Deploy Keys and Personal Access Tokens.
        # Deploy Keys only work for one repo, and we can only specify one per
        # `checkout`, which means we can only pull one submodule per
        # `checkout` - untenable given our already-large-and-growing nested
        # tree of submodules. A Personal Access Token (PAT) lets us identify
        # ourselves as a GitHub user; if we use a dedicated user for that
        # purpose that's about equally powerful as a large collection of
        # Deploy Keys would be, but works for all repositories that we need to
        # pull, allowing us to do a single `checkout` to get our full source
        # tree. Hence we have our `Rebot` user, and use a PAT for that user.
        token: ${{ secrets.private_repo_access_as_rebot_token }}
        submodules: recursive

    # Update references per each submodule path.
    - name: Submodule Update
      run: git submodule update --remote ${{ matrix.path }}

    # The following action will commit all changes to the repo (if any), and
    # either:
    # A) Do nothing, because no changes were committed.
    # B) Open a PR per each submodule to merge the changes to `main`, because no PR existed yet.
    # C) Update an existing PR that was already proposing earlier submodule
    #    updates to also include these latest changes.
    #
    # Since these PRs will only get merged when all checks pass, scenario (C)
    # is most likely to happen when checks fail. In that case there are two
    # possible ways forward:
    #   1. A subsequent update to a submodule fixes the situation, and a later
    #      run of this workflow will update the previously-broken PR to use the
    #      fixed submodule, bringing the PR into a healthy state.
    #   2. The submodule intentionally broke `respect` (this should be rare)
    #      and a human will need to fix to `respect` to be able to do the
    #      submodule update. The human will have to close the broken PR after
    #      they make the fix, so that Rebot will retry the automatic
    #      integration on a subsequent run.
    #
    # Note that Rebot does not automatically close PRs that have become
    # obsolete due to human action, although it will happily re-use an
    # abandoned-but-not-closed PR for later runs that make new updates.
    - name: Create Pull Request or update existing
      id: pr
      uses: peter-evans/create-pull-request@v3
      with:
        # To trigger further workflow runs that would usually be triggered by a
        # PR being opened, we cannot use the standard `GITHUB_TOKEN`, but must
        # use a Personal Access Token instead. See docs:
        #   https://github.com/peter-evans/create-pull-request/blob/main/docs/concepts-guidelines.md#triggering-further-workflow-runs
        # We re-use the one use to pull the repo, above.
        token: ${{ secrets.private_repo_access_as_rebot_token }}
        # The following email address is Rebot's GitHub address - see:
        #   https://github.com/settings/emails
        committer: Rebot <96078724+reboot-dev-bot@users.noreply.github.com>
        author: Rebot <96078724+reboot-dev-bot@users.noreply.github.com>
        commit-message: "[submodule-sync: ${{ matrix.path }}] Update submodule to its latest version"
        title: "[submodule-sync: ${{ matrix.path }}] Update submodule to its latest version"
        body: "Automated update of our submodules to their latest version, by the `submodules-sync` workflow."
        branch: "${{ matrix.path }}-submodule-sync.latest"
        add-paths: ${{ matrix.path }}
        # If a previous run had already created the branch like `submodule-sync.latest`,
        # remove that first, start fresh. This ensures that the PR we
        # open or update always has exactly one commit in it.
        delete-branch: true

    - name: Auto-approve PR
      # We only need to do this when the PR is first created, not on subsequent
      # updates.
      if: steps.pr.outputs.pull-request-operation == 'created'
      uses: juliangruber/approve-pull-request-action@v1
      with:
        github-token: ${{ secrets.token_github }}
        number: ${{ steps.pr.outputs.pull-request-number }}

    # The following three steps aim to create issue in case PR checks failed.
    #
    # Here we are waiting for the PR check status in order to use it in next steps.
    # See docs: https://github.com/marketplace/actions/wait-for-check
    - name: Wait for build to succeed
      uses: fountainhead/action-wait-for-check@v1.0.0
      id: wait-for-build
      with:
        token: ${{ secrets.token_github }}
        checkName: 'Build and Test'
        ref: ${{ steps.pr.outputs.pull-request-head-sha }}
        timeoutSeconds: 3600

    # The following step checks whether the issue has already been created or not for the same submodule.
    # Absence of this step leads to new issues creation on every submodule sync error.
    # If the issue has already been created the next step "Create an issue" will be skipped.
    - name: Check if issue already exists
      # Environment variables to get owner and repository values to use them in `curl` then
      env:
        # The environment variable returns the owner and repository name.
        # For example, reboot-dev/respect.
        # See docs:
        # https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-github-context
        REPO: ${{ github.repository }}
      # The condition below gets list of existing issues using wildcard and
      # generates ISSUE_EXISTS flag and places it to $GITHUB_ENV to use it next step then.
      # If issue exists it get its number to use in step to automatically close it when checks succeed.
      # The folowing style of command is YAML folded style (with '>') which is supported by GitHub Actions.
      # Newlines will be replaced with spaces converting the code to one line.
      # The API URL below is used to search open issues with specific title.
      # See docs: https://docs.github.com/en/rest/reference/search#search-issues-and-pull-requests--parameters
      run: >
        GET_ISSUE_NUMBER=$(curl -s --request GET
        --url https://api.github.com/search/issues\?q=is:issue+is:open+repo:${REPO}+in:title+Submodule+sync+failed+for+"${{ matrix.path }}"
        --header 'Authorization: token ${{ secrets.private_repo_access_as_rebot_token }}' | jq -r ".items[].number" | head -n 1);
        if [[ $GET_ISSUE_NUMBER ]]; then
        echo "Issue exists, skipping next step";
        echo "ISSUE_EXISTS=true" >> $GITHUB_ENV;
        echo "ISSUE_NUMBER=$GET_ISSUE_NUMBER" >> $GITHUB_ENV;
        else
        echo "Issue doesn't exist.";
        echo "ISSUE_EXISTS=false" >> $GITHUB_ENV;
        fi

    # In case checks of PR failed and the issue hadn't been created before the following action creates issue.
    # See docs: https://github.com/actions-ecosystem/action-create-issue
    - name: Create an issue
      if: steps.wait-for-build.outputs.conclusion == 'failure' && env.ISSUE_EXISTS == 'false'
      uses: actions-ecosystem/action-create-issue@v1
      with:
        github_token: ${{ secrets.private_repo_access_as_rebot_token }}
        title: Submodule sync failed for "${{ matrix.path }}"
        body: |
          ## Please check the PR for submodule "${{ matrix.path }}"
          Pull Request URL - ${{ steps.pr.outputs.pull-request-url }}

    # The "mergequeue-failed" label gets added by the Mergequeue bot when it has previously seen
    # the mergequeue-ready label on a PR but the checks failed and Mergequeue couldn't merge the PR.
    # When that happens it removes the "mergequeue-ready" label and adds "mergequeue-failed".
    # Even if we later add the "mergequeue-ready" label to the PR again, Mergequeue won't merge a PR
    # with a new "mergequeue-ready" label if it still has an (old) "mergequeue-failed" label on it.
    # So we must remove the mergequeue-failed label before re-adding mergequeue-ready.
    # The following action removes the "mergequeue-failed" label if it exist.
    # If it doesn't exist the action returns error but doesn't fail the whole job (by default).
    # See docs: https://github.com/actions-ecosystem/action-remove-labels
    - name: Remove label "mergequeue-failed"
      uses: actions-ecosystem/action-remove-labels@v1
      with:
        number: ${{ steps.pr.outputs.pull-request-number }}
        labels: mergequeue-failed

    # We add "mergequeue-ready" label to the pull request created or updated in the step
    # "Create Pull Request or update existing" in order to merge the changes in automatic mode.
    # See docs of the action: https://github.com/actions-ecosystem/action-add-labels
    - name: Add label "mergequeue-ready"
      uses: actions-ecosystem/action-add-labels@v1
      with:
        number: ${{ steps.pr.outputs.pull-request-number }}
        labels: mergequeue-ready

    - name: Close issue if submodule-sync PR checks succeed
      if: steps.wait-for-build.outputs.conclusion == 'success' && env.ISSUE_EXISTS == 'true'
      uses: peter-evans/close-issue@v2
      with:
        issue-number: ${{ env.ISSUE_NUMBER }}
        comment: |
          Auto-closing this issue because checks for the [PR](${{ steps.pr.outputs.pull-request-url }}) succeeded.
